module;
#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <iterator>
#include <ranges>
#include <tuple>
#include <vector>

export module triple.ecs:query;
import triple.refl;
import triple.base;
import :entity;
import :archetype;
import :utils;

namespace triple::ecs {

export class GenericQuery {
    friend class World;

  public:
    class QueryInfo {
      public:
    };

    class Iterator {
      public:
        Iterator(GenericQuery* q, size_t archetype_index, size_t entity_index) :
            m_query(q), m_archetype_index(archetype_index),
            m_entity_index(entity_index) {}

        refl::Ref get(const refl::Type& type) {
            Archetype* archetype = m_query->matched()[m_archetype_index];
            auto iter = std::ranges::find(m_query->components(), &type);
            if (iter == archetype->m_components.end()) {
                log::error("Iterator::get: type mismatch");
                return nullptr;
            }
            auto index = iter - m_query->components().begin();
            return refl::Ref {
                archetype->m_columns[index].get(m_entity_index),
                type
            };
        }

        template<class T>
        T& get() {
            return get(refl::type<T>()).value<T>();
        }

        bool next() {
            m_entity_index++;
            if (m_entity_index ==
                m_query->matched()[m_archetype_index]->size()) {
                m_entity_index = 0;
                m_archetype_index++;
            }
            return m_archetype_index != m_query->matched().size();
        }

        operator bool() const {
            return m_archetype_index != m_query->matched().size();
        }

      private:
        GenericQuery* m_query;
        size_t m_archetype_index;
        size_t m_entity_index;
    };

  public:
    GenericQuery(ComponentVector components) : m_components(components) {
        std::ranges::sort(m_components);
        m_hash = TypeVectorHasher {}(m_components);
    }

    std::size_t hash() const { return m_hash; }

    bool matches(Archetype* archetype) {
        if (archetype->m_components.size() == 0)
            return false;
        for (auto component : m_components) {
            if (std::ranges::find(archetype->m_components, component) ==
                archetype->m_components.end()) {
                return false;
            }
        }
        return true;
    }

    void add_if_matches(Archetype* archetype) {
        if (matches(archetype) &&
            std::ranges::find(m_matched, archetype) == m_matched.end()) {
            m_matched.push_back(archetype);
        }
    }

    const std::vector<Archetype*>& matched() const { return m_matched; }

    const ComponentVector& components() const { return m_components; }

    Iterator iter() { return Iterator(this, 0, 0); }

  protected:
    ComponentVector m_components;
    std::vector<Archetype*> m_matched;
    std::size_t m_hash;
};

export template<class... Args>
class Query {
  public:
    struct Iterator {
        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = std::tuple<Args&...>;
        using pointer = value_type*;
        using reference = value_type&;

        Iterator(Query* q, size_t archetype_index, size_t entity_index) :
            m_query(q), m_archetype_index(archetype_index),
            m_entity_index(entity_index) {}

        template<class T>
        T& get() const {
            const auto& type = refl::type<T>();
            Archetype* archetype = m_query->matched()[m_archetype_index];
            auto iter = std::ranges::find(archetype->m_components, &type);
            if (iter == archetype->m_components.end()) {
                log::error("Iterator::get: type mismatch");
            }
            auto index = iter - archetype->m_components.begin();
            return *static_cast<T*>(
                archetype->m_columns[index].get(m_entity_index)
            );
        }

        value_type operator*() { return {get<Args>()...}; }

        Iterator& operator++() {
            m_entity_index++;
            if (m_entity_index ==
                m_query->matched()[m_archetype_index]->size()) {
                m_entity_index = 0;
                m_archetype_index++;
            }
            return *this;
        }

        bool operator==(Iterator& other) const {
            return m_query == other.m_query &&
                   m_archetype_index == other.m_archetype_index &&
                   m_entity_index == other.m_entity_index;
        }

        bool operator!=(Iterator& other) const { return !(*this == other); }

      private:
        Query* m_query;
        size_t m_archetype_index;
        size_t m_entity_index;
    };

    Query(GenericQuery& q) : m_query(q) {
        // maybe check types
    }

    static size_t hash() {
        return TypeVectorHasher {}({&refl::type<Args>()...});
    }

    static ComponentVector components() { return {&refl::type<Args>()...}; }

    const std::vector<Archetype*>& matched() const { return m_query.matched(); }

    Iterator iter() { return Iterator(this, 0, 0); }

    Iterator begin() { return Iterator(this, 0, 0); }
    Iterator end() { return Iterator(this, matched().size(), 0); }

  private:
    GenericQuery& m_query;
};

} // namespace triple::ecs

namespace std {
template<>
struct hash<triple::ecs::GenericQuery> {
    std::size_t operator()(const triple::ecs::GenericQuery& query) const {
        return query.hash();
    }
};
} // namespace std
