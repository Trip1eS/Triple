module;
#include <algorithm>
#include <cstdint>
#include <cstdlib>
#include <functional>
#include <string>
#include <unordered_map>
#include <vector>

export module triple.ecs:system;
import :query;
import :archetype;
import :event;
import :resource;
import triple.base;
import triple.refl;

namespace triple::ecs {

export using SystemId = std::uint32_t;
class World;
class System;

export class SystemCommands {
  public:
    SystemCommands(System& system);
    GenericQuery& query(const std::string& name = "");
    GenericEventReader& event_reader(const refl::Type& event_type);
    GenericEventWriter& event_writer(const refl::Type& event_type);
    GenericResource& resource(const refl::Type& resource_type);

    template<class T>
    decltype(auto) get_param() {
        using RawT = std::remove_cvref_t<T>;
        if constexpr (is_specialization<RawT, Query>) {
            return RawT(query(std::to_string(RawT::hash())));
        } else if constexpr (is_specialization<RawT, EventReader>) {
            return event_reader(refl::type<RawT::EventType>());
        } else if constexpr (is_specialization<RawT, EventWriter>) {
            return event_writer(refl::type<RawT::EventType>());
        } else if constexpr (is_specialization<RawT, Resource>) {
            return resource(refl::type<RawT::ResourceType>());
        }
    }

  private:
    System& m_system;
};

export class System {
    friend class SystemCommands;

  public:
    // using Callback = void (*)(SystemCommands&);
    using Callback = std::function<void(SystemCommands&)>;

    System(World& world, SystemId id);

    System& callback(Callback func) {
        m_callback = func;
        return *this;
    }

    template<class... Args>
    System& callback(void (*F)(Args...)) {
        m_callback = [F](SystemCommands& commands) {
            F(commands.get_param<Args>()...); //
        };
        return *this;
    }

    System& add_query(const std::string& name, ComponentVector types);
    System& add_event_reader(const refl::Type& event_type);
    System& add_event_wrtier(const refl::Type& event_type);
    System& add_resource(const refl::Type& resource_type);

    template<class... Args>
    System& add_query(const std::string& name = "") {
        return add_query(name, {&refl::type<Args>()...});
    }

    template<class T>
    System& add_param() {
        using RawT = std::remove_cvref_t<T>;
        if constexpr (is_specialization<RawT, Query>) {
            add_query(std::to_string(T::hash()), T::components());
        } else if constexpr (is_specialization<RawT, EventReader>) {
            add_event_reader(refl::type<T::EventType>());
        } else if constexpr (is_specialization<RawT, EventWriter>) {
            add_event_wrtier(refl::type<T::EventType>());
        } else if constexpr (is_specialization<RawT, Resource>) {
            add_resource(refl::type<T::ResourceType>());
        }
        return *this;
    }

    template<class... Args>
    System& add_params() {
        (add_param<Args>(), ...);
        return *this;
    }

    void run() { m_callback(m_commands); }

    SystemId id() const { return m_id; }

    World& world() { return m_world; }

  private:
    World& m_world;
    SystemId m_id;
    Callback m_callback;
    SystemCommands m_commands;
    std::unordered_map<std::string, GenericQuery*> m_queries;
    std::unordered_map<refl::TypeId, GenericEventReader> m_event_readers;
    std::unordered_map<refl::TypeId, GenericEventWriter> m_event_writers;
    std::unordered_map<refl::TypeId, GenericResource> m_resources;
};

} // namespace triple::ecs