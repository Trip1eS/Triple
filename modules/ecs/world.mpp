module;
#include <algorithm>
#include <cstdint>

export module triple.ecs:world;
import :entity;
import :archetype;
import :utils;
import :query;
import :system;
import triple.refl;

namespace triple::ecs {

export class World {
  public:
    World() {
        // create root archetype
        m_root_archetype = create_archetype({});
    }

    ~World() {
        for (auto [_, query] : m_queries) {
            delete query;
        }
        for (auto [_, system] : m_systems) {
            delete system;
        }
        for (Archetype* archetype : m_archetypes) {
            delete archetype;
        }
    }

    Entity entity() {
        EntityId id = next_entity_id();
        m_entity_index[id] = EntityRecord {m_root_archetype, 0};
        return Entity {id};
    }

    Query* query(ComponentVector components) {
        Query* q = new Query(components);
        auto [iter, success] = m_queries.insert({q->hash(), q});
        if (success) {
            for (Archetype* archetype : m_archetypes) {
                q->add_if_matches(archetype);
            }
        } else {
            delete q;
        }
        return iter->second;
    }

    System* system(ComponentVector components) {
        System* s = new System(next_system_id(), query(components));
        m_systems[s->id()] = s;
        return s;
    }

    void add_component(Entity entity, const refl::Type* component) {
        EntityRecord& record = m_entity_index[entity.id()];
        Archetype* archetype = record.m_archetype;
        auto& next_archetype = archetype->m_edges[component->id()].m_add;
        if (next_archetype == nullptr) {
            ComponentVector components = archetype->m_components;
            components.push_back(component);
            next_archetype = create_archetype(components);
        }
        move_entity(archetype, entity.id(), next_archetype);
    }

    void add_component(Entity entity, refl::Ref component) {
        add_component(entity, component.type());
        refl::Ref c = get_component(entity, component.type());
        c.copy(component);
    }

    template<class T>
    void add_component(Entity entity, const T& component) {
        add_component(entity, refl::Ref {component});
    }

    void remove_component(Entity entity, const refl::Type* component) {
        EntityRecord& record = m_entity_index[entity.id()];
        Archetype* archetype = record.m_archetype;
        Archetype*& next_archetype = archetype->m_edges[component->id()].m_remove;
        if (next_archetype == nullptr) {
            ComponentVector components = archetype->m_components;
            components.erase(std::remove(components.begin(), components.end(), component), components.end());
            next_archetype = create_archetype(components);
        }
        move_entity(archetype, entity.id(), next_archetype);
    }

    refl::Ref get_component(Entity entity, const refl::Type* component_type) {
        auto& record = m_entity_index[entity.id()];
        auto* archetype = record.m_archetype;
        auto iter = std::ranges::find(archetype->m_components, component_type);
        if (iter == archetype->m_components.end()) {
            return nullptr;
        }
        auto& column = archetype->m_columns[iter - archetype->m_components.begin()];
        return refl::Ref {column.get(record.m_row), component_type};
    }

    template<class T>
    T& get_component(Entity entity) {
        return get_component(entity, refl::type<T>()).value<T>();
    }

    Archetype* get_archetype(ComponentVector components) {
        std::ranges::sort(components);
        auto iter = m_archetype_map.find(components);
        if (iter != m_archetype_map.end()) {
            return iter->second;
        } else {
            return nullptr;
        }
    }

  private:
    EntityId next_entity_id() {
        static EntityId id = 0;
        return ++id;
    }

    ArchetypeId next_archetype_id() {
        static ArchetypeId id = 0;
        return ++id;
    }

    SystemId next_system_id() {
        static SystemId id = 0;
        return ++id;
    }

    Archetype* create_archetype(const ComponentVector& components) {
        m_archetypes.push_back(new Archetype {});
        Archetype* archetype = m_archetypes.back();
        archetype->m_id = next_archetype_id();
        archetype->m_components = components;
        std::ranges::sort(archetype->m_components);

        // init columns
        archetype->m_columns.reserve(archetype->m_components.size());
        for (std::size_t i = 0; i < archetype->m_components.size(); ++i) {
            archetype->m_columns.push_back(Column {archetype->m_components[i]->size()});
        }

        // add to map
        m_archetype_map[archetype->m_components] = archetype;
        // refresh query list
        for (auto& [_, query] : m_queries) {
            query->add_if_matches(archetype);
        }
        return archetype;
    }

    std::size_t move_entity(Archetype* from, EntityId entity, Archetype* to) {
        std::size_t row = m_entity_index[entity].m_row;
        std::size_t i = 0, j = 0;
        while (i < from->m_components.size() && j < to->m_components.size()) {
            Column& from_column = from->m_columns[i];
            Column& to_column = to->m_columns[j];
            if (from->m_components[i] < to->m_components[j]) {
                if (from != m_root_archetype)
                    from_column.remove(row);
                ++i;
            } else if (from->m_components[i] > to->m_components[j]) {
                to_column.push_back(nullptr);
                ++j;
            } else {
                to_column.push_back(from_column.get(row));
                if (from != m_root_archetype)
                    from_column.remove(row);
                ++i;
                ++j;
            }
        }
        while (i < from->m_components.size()) {
            from->m_columns[i].remove(row);
            ++i;
        }
        while (j < to->m_components.size()) {
            to->m_columns[j].push_back(nullptr);
            ++j;
        }
        auto to_row = to->m_columns[0].m_count - 1;
        m_entity_index[entity].m_archetype = to;
        m_entity_index[entity].m_row = to_row;
        return to_row;
    }

  private:
    std::unordered_map<EntityId, EntityRecord> m_entity_index;
    std::vector<Archetype*> m_archetypes;
    Archetype* m_root_archetype;

    std::unordered_map<ComponentVector, Archetype*, TypeVectorHasher> m_archetype_map;
    std::unordered_map<std::size_t, Query*> m_queries;
    std::unordered_map<SystemId, System*> m_systems;
};

} // namespace triple::ecs