module;
#include <algorithm>
#include <cassert>
#include <cstdint>
#include <map>
#include <memory>
#include <unordered_map>

export module triple.ecs:world;
import triple.refl;
import :entity;
import :event;
import :archetype;
import :utils;
import :query;
import :system;
import :resource;
import :schedule;

namespace triple::ecs {

export struct EntityRecord {
    Archetype* m_archetype;
    std::size_t m_row;
};

export class World {
  public:
    World() {
        // create root archetype
        m_root_archetype = create_archetype({});
    }

    ~World() {
        for (auto [_, query] : m_queries) {
            delete query;
        }
        for (auto [_, system] : m_systems) {
            delete system;
        }
        for (Archetype* archetype : m_archetypes) {
            delete archetype;
        }
    }

    Entity entity() {
        Entity id = next_entity_id();
        m_entity_index[id] = EntityRecord {m_root_archetype, 0};
        return id;
    }

    void despawn(Entity entity) {
        EntityRecord& record = m_entity_index[entity];
        Archetype* archetype = record.m_archetype;
        std::size_t row = record.m_row;
        for (auto& column : archetype->m_columns) {
            column.remove(row);
        }
        m_entity_index.erase(entity);
    }

    GenericQuery& query(ComponentVector components) {
        GenericQuery* q = new GenericQuery(components);
        auto [iter, success] = m_queries.insert({q->hash(), q});
        if (success) {
            for (Archetype* archetype : m_archetypes) {
                q->add_if_matches(archetype);
            }
        } else {
            delete q;
        }
        return *iter->second;
    }

    template<class... Args>
    GenericQuery& query() {
        return query({&refl::type<Args>()...});
    }

    System& system() {
        System* s = new System(*this, next_system_id());
        m_systems[s->id()] = s;
        return *s;
    }

    template<class... Args>
    System& system(void (*F)(Args...)) {
        return system().add_params<Args...>().callback(F);
    }

    template<class... Args>
    SystemId add_system(ScheduleId schedule, void (*F)(Args...)) {
        System& s = system(F);
        get_schedule(schedule).add_system(s.id());
        return s.id();
    }

    void run_system(SystemId id) { m_systems[id]->run(); }

    void add_component(Entity entity, const refl::Type& component) {
        EntityRecord& record = m_entity_index[entity];
        Archetype* archetype = record.m_archetype;
        auto& next_archetype = archetype->m_edges[component.id()].m_add;
        if (next_archetype == nullptr) {
            ComponentVector components = archetype->m_components;
            components.push_back(&component);
            next_archetype = create_archetype(components);
        }
        move_entity(archetype, entity, next_archetype);
    }

    template<class T>
    void add_component(Entity entity) {
        add_component(entity, refl::type<T>());
    }

    void add_component(Entity entity, refl::Ref component) {
        add_component(entity, component.type());
        refl::Ref c = get_component(entity, component.type());
        c.copy(component);
    }

    // template<class T>
    // void add_component(Entity entity, T&& component) {
    //     add_component(entity, refl::Ref {std::forward<T>(component)});
    // }

    void remove_component(Entity entity, const refl::Type& component) {
        EntityRecord& record = m_entity_index[entity];
        Archetype* archetype = record.m_archetype;
        Archetype*& next_archetype = archetype->m_edges[component.id()].m_remove;
        if (next_archetype == nullptr) {
            ComponentVector components = archetype->m_components;
            components.erase(std::remove(components.begin(), components.end(), &component), components.end());
            next_archetype = create_archetype(components);
        }
        move_entity(archetype, entity, next_archetype);
    }

    template<class T>
    void remove_component(Entity entity) {
        remove_component(entity, refl::type<T>());
    }

    refl::Ref get_component(Entity entity, const refl::Type& component_type) {
        auto& record = m_entity_index[entity];
        auto* archetype = record.m_archetype;
        auto iter = std::ranges::find(archetype->m_components, &component_type);
        if (iter == archetype->m_components.end()) {
            return nullptr;
        }
        auto& column = archetype->m_columns[iter - archetype->m_components.begin()];
        return refl::Ref {column.get(record.m_row), component_type};
    }

    template<class T>
    T& get_component(Entity entity) {
        return get_component(entity, refl::type<T>()).value<T>();
    }

    Archetype* get_archetype(ComponentVector components) {
        std::ranges::sort(components);
        auto iter = m_archetype_map.find(TypeVectorHasher {}(components));
        if (iter != m_archetype_map.end()) {
            return iter->second;
        } else {
            return nullptr;
        }
    }

    void add_event(const refl::Type& event_type) {
        if (m_events.find(event_type.id()) != m_events.end())
            return;
        m_events[event_type.id()] = std::make_unique<Events>(event_type);
    }

    template<class E>
    void add_event() {
        add_event(refl::type<E>());
    }

    Events& get_events(const refl::Type& event_type) {
        assert(m_events.find(event_type.id()) != m_events.end());
        return *m_events[event_type.id()];
    }

    template<class E>
    Events& get_events() {
        return get_events(refl::type<E>());
    }

    // void add_resource(const refl::Type& resource) { m_resources[resource.type().id()] = resource; }

    template<class R>
    void add_resource() {
        using RawR = std::remove_cvref_t<R>;
        log::trace("Adding resource: {}", refl::type<R>().name());
        // m_resources[refl::type<R>().id()] = R {};
        m_resources.emplace(refl::type<R>().id(), R {});
    }

    GenericResource get_resource(const refl::Type& resource_type) {
        assert(m_resources.find(resource_type.id()) != m_resources.end());
        return GenericResource {m_resources[resource_type.id()].ref()};
    }

    template<class R>
    Resource<R> get_resource() {
        return get_resource(refl::type<R>());
    }

    void add_schedule(ScheduleId id) { m_schedules[id] = std::make_unique<Schedule>(id); }

    Schedule& get_schedule(ScheduleId id) {
        assert(m_schedules.find(id) != m_schedules.end());
        return *m_schedules[id];
    }

    void run_schedule(ScheduleId id) {
        auto& schedule = get_schedule(id);
        for (SystemId system_id : schedule.systems()) {
            run_system(system_id);
        }
    }

  private:
    Entity next_entity_id() {
        static Entity id = 0;
        return ++id;
    }

    ArchetypeId next_archetype_id() {
        static ArchetypeId id = 0;
        return ++id;
    }

    SystemId next_system_id() {
        static SystemId id = 0;
        return ++id;
    }

    Archetype* create_archetype(const ComponentVector& components) {
        m_archetypes.push_back(new Archetype {});
        Archetype* archetype = m_archetypes.back();
        archetype->m_id = next_archetype_id();
        archetype->m_components = components;
        std::ranges::sort(archetype->m_components);

        // init columns
        archetype->m_columns.reserve(archetype->m_components.size());
        for (std::size_t i = 0; i < archetype->m_components.size(); ++i) {
            archetype->m_columns.push_back(Column {archetype->m_components[i]->size()});
        }

        // add to map
        m_archetype_map[archetype->hash()] = archetype;
        // refresh query list
        for (auto& [_, query] : m_queries) {
            query->add_if_matches(archetype);
        }
        return archetype;
    }

    std::size_t move_entity(Archetype* from, Entity entity, Archetype* to) {
        std::size_t row = m_entity_index[entity].m_row;
        std::size_t i = 0, j = 0;
        while (i < from->m_components.size() && j < to->m_components.size()) {
            Column& from_column = from->m_columns[i];
            Column& to_column = to->m_columns[j];
            if (from->m_components[i] < to->m_components[j]) {
                if (from != m_root_archetype)
                    from_column.remove(row);
                ++i;
            } else if (from->m_components[i] > to->m_components[j]) {
                to_column.push_back(nullptr);
                ++j;
            } else {
                to_column.push_back(from_column.get(row));
                if (from != m_root_archetype)
                    from_column.remove(row);
                ++i;
                ++j;
            }
        }
        while (i < from->m_components.size()) {
            from->m_columns[i].remove(row);
            ++i;
        }
        while (j < to->m_components.size()) {
            to->m_columns[j].push_back(nullptr);
            ++j;
        }
        auto to_row = to->m_columns[0].m_count - 1;
        m_entity_index[entity].m_archetype = to;
        m_entity_index[entity].m_row = to_row;
        return to_row;
    }

  private:
    std::vector<Archetype*> m_archetypes;
    Archetype* m_root_archetype;

    // NOTE: Strange compiler internal error happening here if I use std::unordered_map
    // So I'm using std::map instead for now
    // "fatal error C1001: Internal compiler error. (compiler file 'msc1.cpp', line 1587)"

    std::map<std::size_t, EntityRecord> m_entity_index;
    std::map<std::size_t, Archetype*> m_archetype_map;
    std::map<std::size_t, GenericQuery*> m_queries;
    std::map<SystemId, System*> m_systems;
    std::map<refl::TypeId, std::unique_ptr<Events>> m_events;
    std::map<refl::TypeId, refl::Value> m_resources;
    std::map<ScheduleId, std::unique_ptr<Schedule>> m_schedules;
};

} // namespace triple::ecs
