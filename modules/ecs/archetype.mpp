module;
#include <algorithm>
#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <unordered_map>
#include <vector>

export module triple.ecs:archetype;
import :entity;
import :utils;
import triple.refl;
import triple.base;

namespace triple::ecs {

export using ComponentId = std::uint32_t;
export using ArchetypeId = std::uint32_t;
export using ComponentVector = std::vector<const refl::Type*>;

export struct Column {
    void* m_elements;
    std::size_t m_element_size;
    std::size_t m_count;
    std::size_t m_capacity;

    Column(std::size_t element_size) :
        m_element_size(element_size), m_count(0), m_capacity(64) {
        m_elements = std::malloc(element_size * m_capacity);
    }

    void set(std::size_t row, const void* element) {
        if (element == nullptr)
            std::memset(
                static_cast<char*>(m_elements) + row * m_element_size,
                0,
                m_element_size
            );
        else
            std::memcpy(
                static_cast<char*>(m_elements) + row * m_element_size,
                element,
                m_element_size
            );
    }

    void push_back(const void* element) {
        if (m_count == m_capacity) {
            m_capacity *= 2;
            m_elements = std::realloc(m_elements, m_element_size * m_capacity);
        }
        set(m_count, element);
        ++m_count;
    }

    void* get(std::size_t row) {
        return static_cast<char*>(m_elements) + row * m_element_size;
    }

    void remove(std::size_t row) {
        if (row != m_count - 1)
            std::memcpy(
                static_cast<char*>(m_elements) + row * m_element_size,
                static_cast<char*>(m_elements) + (m_count - 1) * m_element_size,
                m_element_size
            );
        --m_count;
    }
};

export struct Archetype {
    struct Edge {
        Archetype *m_add, *m_remove;
    };
    std::unordered_map<ComponentId, Edge> m_edges;

    Archetype(ArchetypeId id, const ComponentVector& components) :
        m_id(id), m_components(components) {
        std::ranges::sort(m_components);
        for (const auto& component : m_components) {
            m_columns.emplace_back(component->size());
        }
        assert(m_entity_row.size() == m_entities.size());
    }

    std::size_t size() const { return m_entity_row.size(); }

    bool has_entity(Entity entity) const {
        return m_entity_row.find(entity) != m_entity_row.end();
    }

    bool check() const {
        if (m_entities.size() != m_entity_row.size()) {
            return false;
        }
        for (auto entity : m_entities) {
            if (m_entity_row.find(entity) == m_entity_row.end()) {
                return false;
            }
        }
        return true;
    }

    bool has_component(const refl::Type& component) const {
        return std::find(
                   m_components.begin(),
                   m_components.end(),
                   &component
               ) != m_components.end();
    }

    void add_entity(Entity entity) {
        assert(!has_entity(entity));
        m_entity_row[entity] = m_entities.size();
        m_entities.push_back(entity);
        for (auto& column : m_columns) {
            column.push_back(nullptr);
        }
        assert(check());
    }

    void* get_component(Entity entity, const refl::Type& component) {
        assert(has_component(component));
        assert(has_entity(entity));
        auto row = m_entity_row[entity];
        auto component_index =
            std::find(m_components.begin(), m_components.end(), &component) -
            m_components.begin();
        assert(check());
        return m_columns[component_index].get(row);
    }

    void set_component(
        Entity entity,
        const refl::Type& component,
        const void* data
    ) {
        assert(has_component(component));
        assert(has_entity(entity));
        auto row = m_entity_row[entity];
        auto component_index =
            std::find(m_components.begin(), m_components.end(), &component) -
            m_components.begin();
        m_columns[component_index].set(row, data);
        assert(check());
    }

    void remove_entity(Entity entity) {
        // if (m_id == 11)
        //     log::trace("Archetype {} removing entity {}", m_id, entity);
        assert(has_entity(entity));
        auto row = m_entity_row[entity];
        for (auto& column : m_columns) {
            column.remove(row);
        }
        m_entity_row.erase(entity);
        if (row == m_entities.size() - 1) {
            m_entities.pop_back();
        } else {
            Entity last_entity = m_entities.back();
            m_entity_row[last_entity] = row;
            m_entities[row] = last_entity;
            m_entities.pop_back();
        }
        assert(check());
    }

    const ComponentVector& components() const { return m_components; }

    const std::vector<Entity>& entities() const { return m_entities; }

    std::size_t hash() const { return TypeVectorHasher {}(m_components); }

    ArchetypeId id() const { return m_id; }

  private:
    ArchetypeId m_id;
    ComponentVector m_components;
    std::vector<Column> m_columns;
    std::vector<Entity> m_entities;
    std::unordered_map<Entity, std::size_t> m_entity_row;
};

} // namespace triple::ecs
